### 4.1 合约介绍

在这一节里面，我们实现一个基础的智能合约：NumSaver。

```javascript
pragma solidity 0.4.22;

contract NumSaver{

    uint private _num;
    function store(uint256 num) public {
        _num = num;   
    }

    function get() public view returns (uint256){
        return _num;
    }
}
```

这段Solidity代码的功能是存取_num字段。该字段被称为“状态变量”，会由区块链持久存储。 

用户可以将这段代码部署在以太坊或类似的区块链上，部署成功就意味着该智能合约不可再被修改，只要底层区块链不被销毁，这段合约就一直存在。任何人都可通过“合约地址”来调用该合约接口，每次调用信息都会被记录在链上。

在讲解这段代码如何运行之前，我们先回顾下传统java程序的运行方式。

首先，用户编译完java代码后，会以字节码的形式保存在磁盘上；然后用户会调用程序，这由JVM来托管执行；程序执行期间可能会通过日志来记录调用参数，也可能会和磁盘进行IO。 

Solidity的执行与此类似。不同的是介质由硬盘换成了区块链，由单机变为分布式。 

代码部署后，以字节码的形式存储在每一个节点上。当用户要求调用某个函数时，调用请求将会被囊括在交易中，并被打包到某个区块上，一旦全网对该区块形成共识，就意味着调用是合法的。

接下来，EVM会来调用字节码，它负责存取底层的状态变量，好比传统编程的IO。



![img](https://tva1.sinaimg.cn/large/00831rSTly1gckc3t9jkwj30u00dz0uz.jpg)



光从代码来看，合约开发似乎不过如此，单个合约只需要围绕着字段进行操作，对于很多简单业务而言，不过是CRUD而已。

但其复杂性也恰恰在于此，合约在区块链环境上执行，是不可修改的。

所以如果出现了bug，就必须部署新的合约，这对于合约的可维护性提出了挑战。并且，一旦业务复杂起来，容易出现安全漏洞，导致链上资产损失。同时，还要考虑完成代码编写、逻辑执行、数据存储的成本问题。 

综上所述，写合约不难，但写好合约，却需要一定功底。

### 4.2 合约部署

参照 3，Remix 发行标准代币进行合约部署。

### 4.3 合约调用

部署之后会自动识别接口，在Remix界面上出现两个方法：

<img src="https://tva1.sinaimg.cn/large/00831rSTly1gckca2jratj30hc10aju3.jpg" alt="image-20200306173236520" style="zoom:50%;" />

输入一个数字，点击 store，会调取 metamask 发送交易，进行值的存储，待交易确认后，点击 get，会返回刚才存储的数。

<img src="https://tva1.sinaimg.cn/large/00831rSTly1gckcbj0cslj325k0l20yg.jpg" alt="image-20200306173405770" style="zoom:50%;" />